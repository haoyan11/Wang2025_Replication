X_tr_full <- cbind(sos_z, gpp_z, p_pre_z, t_pre_z, sw_pre_z,
p_season_z, t_season_z, sw_season_z)
X_tr <- X_tr_full
vars_current <- vars_tr
# VIF过滤
if (ncol(X_tr) > 1) {
repeat {
vifs <- calc_vif_vector(X_tr)
if (all(is.finite(vifs)) && max(vifs) > 10 && ncol(X_tr) > 1) {
rm_idx <- which.max(vifs)
X_tr <- X_tr[, -rm_idx, drop = FALSE]
vars_current <- vars_current[-rm_idx]
if (ncol(X_tr) <= 1) {
break
}
} else {
break
}
}
}
d <- rep(NA_real_, length(vars_tr))
p_d <- rep(NA_real_, length(vars_tr))
if (ncol(X_tr) >= 1) {
d_res <- regress_beta_p(X_tr, fixed_trate_z)  # 修改：trc_z → fixed_trate_z
if (!any(is.na(d_res$beta)) && !any(is.na(d_res$p))) {
for (j in seq_along(vars_current)) {
idx_match <- match(vars_current[j], vars_tr)
d[idx_match] <- d_res$beta[j]
p_d[idx_match] <- d_res$p[j]
}
}
}
if (any(is.na(c(a, b, c, f))) || any(is.na(c(p_a, p_b, p_c, p_f))) || all(is.na(d))) {
next
}
vals <- c(
a[1], a[2], a[3],
b,
f[1], f[2], f[3],
c[1], c[2], c[3],
d[1], d[2], d[3], d[4], d[5], d[6], d[7], d[8],
a[1] * b * d[2],
a[2] * b * d[2],
a[3] * b * d[2]
)
p_vals <- c(
p_a[1], p_a[2], p_a[3],
p_b,
p_f[1], p_f[2], p_f[3],
p_c[1], p_c[2], p_c[3],
p_d[1], p_d[2], p_d[3], p_d[4], p_d[5], p_d[6], p_d[7], p_d[8],
NA_real_, NA_real_, NA_real_
)
for (k in seq_along(coef_names)) {
if (is.finite(vals[k])) {
coef_sum[coef_names[k]] <- coef_sum[coef_names[k]] + vals[k]
coef_sumsq[coef_names[k]] <- coef_sumsq[coef_names[k]] + vals[k]^2
coef_count[coef_names[k]] <- coef_count[coef_names[k]] + 1
if (is.finite(p_vals[k]) && p_vals[k] < 0.05) {
sig_sum[coef_names[k]] <- sig_sum[coef_names[k]] + vals[k]
sig_sumsq[coef_names[k]] <- sig_sumsq[coef_names[k]] + vals[k]^2
sig_count[coef_names[k]] <- sig_count[coef_names[k]] + 1
}
}
}
}
}
mean_vals <- coef_sum / coef_count
sd_vals <- sqrt(pmax(0, coef_sumsq / coef_count - mean_vals^2))
sig_frac <- sig_count / coef_count
mean_sig <- sig_sum / sig_count
sd_sig <- sqrt(pmax(0, sig_sumsq / sig_count - mean_sig^2))
mean_vals[!is.finite(mean_vals)] <- NA_real_
sd_vals[!is.finite(sd_vals)] <- NA_real_
sig_frac[!is.finite(sig_frac)] <- NA_real_
mean_sig[!is.finite(mean_sig)] <- NA_real_
sd_sig[!is.finite(sd_sig)] <- NA_real_
summary_df <- data.frame(
path = coef_names,
mean = mean_vals,
sd = sd_vals,
n = coef_count,
sig_n = sig_count,
sig_frac = sig_frac,
mean_sig = mean_sig,
sd_sig = sd_sig
)
write.csv(summary_df, file.path(PIXELWISE_DIR, "SEM_dual_timescale_pixel_time_series_summary.csv"),
row.names = FALSE)
cat("\n像元时间序列SEM摘要:\n")
print(summary_df)
summary_df
}
# ==================== SEM分析（全局合并）====================
# ===【修改7】添加POSav气候态计算===
run_dual_timescale_sem <- function(years, mask_r) {
cat("\n=== 计算物候气候态（像元多年平均：SOSav, POSav） ===\n")
# 读取所有年份的SOS和POS数据并计算多年平均
sos_stack_list <- list()
pos_stack_list <- list()
n_loaded_sos <- 0
n_loaded_pos <- 0
for (year in years) {
sos_file <- file.path(PHENO_DIR, sprintf("sos_gpp_%d.tif", year))
pos_file <- file.path(PHENO_DIR, sprintf("pos_doy_gpp_%d.tif", year))
if (file.exists(sos_file)) {
sos_r <- raster(sos_file)
NAvalue(sos_r) <- NODATA_OUT
sos_r <- mask_raster(sos_r, mask_r)
sos_stack_list[[length(sos_stack_list) + 1]] <- sos_r
n_loaded_sos <- n_loaded_sos + 1
}
if (file.exists(pos_file)) {
pos_r <- raster(pos_file)
NAvalue(pos_r) <- NODATA_OUT
pos_r <- mask_raster(pos_r, mask_r)
pos_stack_list[[length(pos_stack_list) + 1]] <- pos_r
n_loaded_pos <- n_loaded_pos + 1
}
if ((n_loaded_sos %% 10 == 0) && (n_loaded_sos > 0)) {
cat(sprintf("  已读取 %d/%d 年份的物候数据...\n", n_loaded_sos, length(years)))
}
}
cat(sprintf("  ✓ 成功读取 %d/%d 年份的SOS数据\n", n_loaded_sos, length(years)))
cat(sprintf("  ✓ 成功读取 %d/%d 年份的POS数据\n", n_loaded_pos, length(years)))
if (n_loaded_sos == 0 || n_loaded_pos == 0) {
stop("未找到足够的SOS或POS数据文件")
}
# 将列表转换为stack并计算多年平均
cat("  正在计算SOS多年平均（SOSav）...\n")
sos_stack <- stack(sos_stack_list)
sos_climatology_r <- calc(sos_stack, fun = function(x) {
mean(x, na.rm = TRUE)
})
sos_climatology_r <- mask_raster(sos_climatology_r, mask_r)
cat("  正在计算POS多年平均（POSav）...\n")
pos_stack <- stack(pos_stack_list)
pos_climatology_r <- calc(pos_stack, fun = function(x) {
mean(x, na.rm = TRUE)
})
pos_climatology_r <- mask_raster(pos_climatology_r, mask_r)
# ===【修改：添加POS > SOS验证】===
cat("  验证POSav > SOSav...\n")
valid_window_mask <- pos_climatology_r > sos_climatology_r
sos_climatology_r <- mask(sos_climatology_r, valid_window_mask, maskvalue = 0)
pos_climatology_r <- mask(pos_climatology_r, valid_window_mask, maskvalue = 0)
n_invalid <- sum(getValues(valid_window_mask) == 0, na.rm = TRUE)
if (n_invalid > 0) {
cat(sprintf("  ⚠️ 过滤了 %d 个POSav≤SOSav的无效像元\n", n_invalid))
}
# 统计气候态信息
sos_clim_vals <- getValues(sos_climatology_r)
sos_clim_vals <- sanitize_values(sos_clim_vals, NAvalue(sos_climatology_r), FALSE)
pos_clim_vals <- getValues(pos_climatology_r)
pos_clim_vals <- sanitize_values(pos_clim_vals, NAvalue(pos_climatology_r), FALSE)
n_valid_sos <- sum(!is.na(sos_clim_vals))
n_valid_pos <- sum(!is.na(pos_clim_vals))
sos_min <- min(sos_clim_vals, na.rm = TRUE)
sos_max <- max(sos_clim_vals, na.rm = TRUE)
sos_mean <- mean(sos_clim_vals, na.rm = TRUE)
pos_min <- min(pos_clim_vals, na.rm = TRUE)
pos_max <- max(pos_clim_vals, na.rm = TRUE)
pos_mean <- mean(pos_clim_vals, na.rm = TRUE)
cat(sprintf("  ✓ 物候气候态计算完成:\n"))
cat(sprintf("    SOSav - 有效像元: %d, 范围: %.1f - %.1f DOY, 平均: %.1f DOY\n",
n_valid_sos, sos_min, sos_max, sos_mean))
cat(sprintf("    POSav - 有效像元: %d, 范围: %.1f - %.1f DOY, 平均: %.1f DOY\n",
n_valid_pos, pos_min, pos_max, pos_mean))
# 保存物候气候态
sos_clim_file <- file.path(DERIVED_DIR, "SOS_climatology.tif")
pos_clim_file <- file.path(DERIVED_DIR, "POS_climatology.tif")
writeRaster(sos_climatology_r, sos_clim_file, overwrite = TRUE, datatype = "FLT4S")
writeRaster(pos_climatology_r, pos_clim_file, overwrite = TRUE, datatype = "FLT4S")
cat(sprintf("  ✓ 物候气候态已保存: %s, %s\n", basename(sos_clim_file), basename(pos_clim_file)))
# 读取Fixed_Window_Length（用于计算Fixed_Trate）
cat("\n=== 读取Fixed_Window_Length ===\n")
fixed_len_file <- file.path(DECOMP_DIR, "Fixed_Window_Length.tif")
if (!file.exists(fixed_len_file)) {
stop(sprintf("Fixed_Window_Length文件不存在: %s", fixed_len_file))
}
fixed_window_length_r <- raster(fixed_len_file)
NAvalue(fixed_window_length_r) <- NODATA_OUT
fixed_window_length_r <- mask_raster(fixed_window_length_r, mask_r)
cat(sprintf("  ✓ Fixed_Window_Length已加载: %s\n", basename(fixed_len_file)))
cat("\n=== 准备SEM数据 ===\n")
sem_data <- data.frame()
# ===【修改8】调用时传入POSav和fixed_window_length_r参数，数据框列名改为Fixed_Trate===
for (year in years) {
rasters <- prepare_dual_timescale_data(year, sos_climatology_r, pos_climatology_r,
fixed_window_length_r, mask_r)
if (is.null(rasters)) next
if (SEM_SAMPLE_MODE == "annual_mean") {
year_row <- data.frame(
year = year,
Fixed_Trate = cellStats(rasters$fixed_trate, mean, na.rm = TRUE),  # 修改：TRc → Fixed_Trate, trc → fixed_trate
SOS = cellStats(rasters$sos, mean, na.rm = TRUE),
GPP_season = cellStats(rasters$gpp_season, mean, na.rm = TRUE),
P_pre = cellStats(rasters$p_pre, mean, na.rm = TRUE),
T_pre = cellStats(rasters$t_pre, mean, na.rm = TRUE),
SW_pre = cellStats(rasters$sw_pre, mean, na.rm = TRUE),
P_season = cellStats(rasters$p_season, mean, na.rm = TRUE),
T_season = cellStats(rasters$t_season, mean, na.rm = TRUE),
SW_season = cellStats(rasters$sw_season, mean, na.rm = TRUE)
)
sem_data <- rbind(sem_data, year_row)
cat(sprintf("  年份 %d: 全域均值已添加\n", year))
} else {
# 提取像元值
vals <- data.frame(
year = year,
Fixed_Trate = sanitize_values(getValues(rasters$fixed_trate), NAvalue(rasters$fixed_trate), TRUE),  # 修改：TRc → Fixed_Trate, trc → fixed_trate
SOS = sanitize_values(getValues(rasters$sos), NAvalue(rasters$sos), FALSE),
GPP_season = sanitize_values(getValues(rasters$gpp_season), NAvalue(rasters$gpp_season), FALSE),
P_pre = sanitize_values(getValues(rasters$p_pre), NAvalue(rasters$p_pre), FALSE),
T_pre = sanitize_values(getValues(rasters$t_pre), NAvalue(rasters$t_pre), TRUE),
SW_pre = sanitize_values(getValues(rasters$sw_pre), NAvalue(rasters$sw_pre), FALSE),
P_season = sanitize_values(getValues(rasters$p_season), NAvalue(rasters$p_season), FALSE),
T_season = sanitize_values(getValues(rasters$t_season), NAvalue(rasters$t_season), TRUE),
SW_season = sanitize_values(getValues(rasters$sw_season), NAvalue(rasters$sw_season), FALSE)
)
vals <- vals[complete.cases(vals), ]
sem_data <- rbind(sem_data, vals)
cat(sprintf("  年份 %d: %d 完整案例\n", year, nrow(vals)))
}
}
# 数据质量检查
cat("\n数据质量检查:\n")
cat(sprintf("  总样本数: %d\n", nrow(sem_data)))
cat(sprintf("  完整案例数: %d\n", sum(complete.cases(sem_data))))
# 修改：TRc → Fixed_Trate
for (col in c("Fixed_Trate", "SOS", "GPP_season", "P_pre", "T_pre", "SW_pre",
"P_season", "T_season", "SW_season")) {
valid_n <- sum(is.finite(sem_data[[col]]))
mean_val <- mean(sem_data[[col]], na.rm = TRUE)
cat(sprintf("  %s: %d个有效值, 均值=%.3f\n", col, valid_n, mean_val))
}
# 检查是否有足够的有效数据
min_samples <- ifelse(SEM_SAMPLE_MODE == "annual_mean", 3, 100)
if (sum(complete.cases(sem_data)) < min_samples) {
cat(sprintf("\n✗ 错误：完整案例数不足（<%d），无法进行SEM分析\n", min_samples))
cat("可能原因:\n")
cat("  1. 日尺度数据文件路径不正确\n")
cat("  2. 日尺度数据缺失\n")
cat("  3. 掩膜过于严格导致无有效像元\n")
cat("\n请检查以下路径:\n")
cat(sprintf("  GPP日尺度: %s\n", GPP_DAILY_DIR))
cat(sprintf("  降水日尺度: %s\n", PRECIP_DAILY_DIR))
cat(sprintf("  气温日尺度: %s\n", TA_DAILY_DIR))
cat(sprintf("  短波辐射日尺度: %s\n", SW_DAILY_DIR))
stop("数据准备失败：完整案例数不足")
}
# Z-score标准化
sem_data_std <- sem_data
sem_vars <- setdiff(names(sem_data_std), "year")
sem_data_std[sem_vars] <- scale(sem_data_std[sem_vars])
# 保存原始和标准化数据
write.csv(sem_data, file.path(DATA_DIR, "sem_dual_timescale_raw.csv"), row.names = FALSE)
write.csv(sem_data_std, file.path(DATA_DIR, "sem_dual_timescale_standardized.csv"), row.names = FALSE)
cat("✓ SEM数据准备完成\n")
# ===== 构建双时间尺度SEM模型 =====
# ===【修改9】SEM模型：Fixed_Trate替代TRc===
cat("\n=== 构建双时间尺度SEM模型（固定窗口方法） ===\n")
cat("✓ 气候因子: 降水(P)、气温(T)、短波辐射(SW)\n")
cat("✓ 时间窗口: 季前气候（SOSav前3个月）+ 生长季气候（固定窗口[SOSav, POSav]）\n")
cat("✓ 因变量: Fixed_Trate（固定窗口蒸腾速率）\n")
# 完整路径模型（降水 + 温度 + 短波辐射）
sem_model <- '
# 第一层：季前气候 → SOS（物候响应）
SOS ~ a1*P_pre + a2*T_pre + a3*SW_pre
# 第二层：SOS + 季前气候 + 生长季气候 → GPP_season（碳固定）
GPP_season ~ b*SOS + f1*P_pre + f2*T_pre + f3*SW_pre +
c1*P_season + c2*T_season + c3*SW_season
# 第三层：SOS + GPP_season + 季前气候 + 生长季气候 → Fixed_Trate（固定窗口蒸腾速率）
Fixed_Trate ~ g*SOS + d*GPP_season +
h1*P_pre + h2*T_pre + h3*SW_pre +
e1*P_season + e2*T_season + e3*SW_season
# === 间接效应分解 ===
# 季前气候的间接效应路径
P_pre_via_SOS_GPP  := a1 * b * d
T_pre_via_SOS_GPP  := a2 * b * d
SW_pre_via_SOS_GPP := a3 * b * d
P_pre_via_SOS  := a1 * g
T_pre_via_SOS  := a2 * g
SW_pre_via_SOS := a3 * g
P_pre_via_GPP  := f1 * d
T_pre_via_GPP  := f2 * d
SW_pre_via_GPP := f3 * d
# 季前气候的总间接效应
P_pre_indirect  := a1*b*d + a1*g + f1*d
T_pre_indirect  := a2*b*d + a2*g + f2*d
SW_pre_indirect := a3*b*d + a3*g + f3*d
# 生长季气候通过GPP的间接效应
P_season_via_GPP  := c1 * d
T_season_via_GPP  := c2 * d
SW_season_via_GPP := c3 * d
# GPP的中介比例
P_GPP_mediation := (c1*d) / (e1 + c1*d)
T_GPP_mediation := (c2*d) / (e2 + c2*d)
SW_GPP_mediation := (c3*d) / (e3 + c3*d)
'
cat("\nSEM模型结构:\n")
cat(sem_model)
cat("\n")
# ===== 拟合SEM模型 =====
cat("\n=== 拟合SEM模型 ===\n")
fit <- sem(sem_model, data = sem_data_std, estimator = "MLR")
cat("\nSEM拟合摘要:\n")
summary(fit, fit.measures = TRUE, standardized = TRUE, rsquare = TRUE)
# 保存结果
params <- parameterEstimates(fit, standardized = TRUE)
write.csv(params, file.path(OUTPUT_DIR, "SEM_dual_timescale_parameters.csv"), row.names = FALSE)
fit_measures <- fitMeasures(fit, c("chisq", "df", "pvalue", "cfi", "tli", "rmsea", "srmr"))
write.csv(t(as.data.frame(fit_measures)), file.path(OUTPUT_DIR, "SEM_dual_timescale_fitindices.csv"))
# 路径图
pdf(file.path(OUTPUT_DIR, "SEM_dual_timescale_pathdiagram.pdf"), width = 12, height = 10)
semPaths(
fit,
what = "std",
layout = "tree2",
edge.label.cex = 0.8,
curvePivot = TRUE,
fade = FALSE,
residuals = FALSE,
intercepts = FALSE,
nCharNodes = 0,
sizeMan = 8,
sizeLat = 10,
title = TRUE,
mar = c(3, 3, 3, 3)
)
dev.off()
cat("✓ 双时间尺度SEM分析完成\n")
cat(sprintf("  输出目录: %s\n", OUTPUT_DIR))
fit
}
# ==================== 主函数 ====================
main <- function() {
cat("\n======================================================================\n")
cat("双时间尺度SEM分析 - 与N04路径结构对齐\n")
cat("======================================================================\n")
cat(sprintf("分析模式: %s\n", SEM_SAMPLE_MODE))
cat(sprintf("年份范围: %d-%d\n", YEAR_START, YEAR_END))
cat("----------------------------------------------------------------------\n")
years <- YEAR_START:YEAR_END
# 诊断日尺度数据文件（使用第一年作为测试）
cat("\n[日尺度文件诊断 - 测试年份: 1982]\n")
diagnose_daily_files(1982, GPP_DAILY_DIR, GPP_DAILY_PATTERN, sample_dates = 3)
diagnose_daily_files(1982, PRECIP_DAILY_DIR, PRECIP_DAILY_PATTERN, sample_dates = 3)
diagnose_daily_files(1982, TA_DAILY_DIR, TA_DAILY_PATTERN, sample_dates = 3)
diagnose_daily_files(1982, SW_DAILY_DIR, SW_DAILY_PATTERN, sample_dates = 3)
# 读取并诊断掩膜
cat("\n[掩膜诊断]\n")
mask_r <- raster(MASK_FILE)
cat(sprintf("  掩膜文件: %s\n", MASK_FILE))
cat(sprintf("  栅格尺寸: %d x %d (行 x 列)\n", nrow(mask_r), ncol(mask_r)))
cat(sprintf("  总像元数: %d\n", ncell(mask_r)))
mask_vals_orig <- getValues(mask_r)
n_valid_orig <- sum(mask_vals_orig > 0, na.rm = TRUE)
cat(sprintf("  原始有效像元数 (>0): %d (%.2f%%)\n",
n_valid_orig, 100 * n_valid_orig / ncell(mask_r)))
mask_r[mask_r <= 0] <- NA
mask_vals <- getValues(mask_r)
n_valid <- sum(!is.na(mask_vals))
cat(sprintf("  处理后有效像元数: %d (%.2f%%)\n",
n_valid, 100 * n_valid / ncell(mask_r)))
if (n_valid == 0) {
cat("\n⚠️ 警告：掩膜处理后没有任何有效像元！\n")
cat("  这会导致所有计算结果为NA\n")
cat("  建议检查掩膜文件是否正确\n")
}
# 测试读取一个实际的日尺度文件
cat("\n[测试读取日尺度文件]\n")
test_gpp_file <- file.path(GPP_DAILY_DIR, "GPP_19820301.tif")
cat(sprintf("  测试文件: %s\n", basename(test_gpp_file)))
cat(sprintf("  文件存在: %s\n", ifelse(file.exists(test_gpp_file), "是", "否")))
if (file.exists(test_gpp_file)) {
tryCatch({
test_r <- raster(test_gpp_file)
cat(sprintf("  栅格尺寸: %d x %d\n", nrow(test_r), ncol(test_r)))
test_vals <- getValues(test_r)
n_valid_test <- sum(is.finite(test_vals) & test_vals > 0, na.rm = TRUE)
cat(sprintf("  有效像元数 (>0): %d (%.2f%%)\n",
n_valid_test, 100 * n_valid_test / length(test_vals)))
# 应用掩膜后
test_r_masked <- mask(test_r, mask_r)
test_vals_masked <- getValues(test_r_masked)
n_valid_masked <- sum(is.finite(test_vals_masked) & test_vals_masked > 0, na.rm = TRUE)
cat(sprintf("  应用掩膜后有效像元数: %d (%.2f%%)\n",
n_valid_masked, 100 * n_valid_masked / length(test_vals_masked)))
cat(sprintf("  掩膜后均值: %.4f\n", mean(test_vals_masked, na.rm = TRUE)))
}, error = function(e) {
cat(sprintf("  ✗ 读取失败: %s\n", conditionMessage(e)))
})
}
cat("----------------------------------------------------------------------\n")
# 运行双时间尺度SEM
# ===【修改10】像元时间序列模式：添加POSav气候态计算===
if (SEM_SAMPLE_MODE == "pixel_time_series") {
# 先计算物候气候态（SOSav, POSav）
cat("\n=== 计算物候气候态（像元多年平均：SOSav, POSav） ===\n")
sos_stack_list <- list()
pos_stack_list <- list()
n_loaded_sos <- 0
n_loaded_pos <- 0
for (year in years) {
sos_file <- file.path(PHENO_DIR, sprintf("sos_gpp_%d.tif", year))
pos_file <- file.path(PHENO_DIR, sprintf("pos_doy_gpp_%d.tif", year))
if (file.exists(sos_file)) {
sos_r <- raster(sos_file)
NAvalue(sos_r) <- NODATA_OUT
sos_r <- mask_raster(sos_r, mask_r)
sos_stack_list[[length(sos_stack_list) + 1]] <- sos_r
n_loaded_sos <- n_loaded_sos + 1
}
if (file.exists(pos_file)) {
pos_r <- raster(pos_file)
NAvalue(pos_r) <- NODATA_OUT
pos_r <- mask_raster(pos_r, mask_r)
pos_stack_list[[length(pos_stack_list) + 1]] <- pos_r
n_loaded_pos <- n_loaded_pos + 1
}
if ((n_loaded_sos %% 10 == 0) && (n_loaded_sos > 0)) {
cat(sprintf("  已读取 %d/%d 年份的物候数据...\n", n_loaded_sos, length(years)))
}
}
cat(sprintf("  ✓ 成功读取 %d/%d 年份的SOS数据\n", n_loaded_sos, length(years)))
cat(sprintf("  ✓ 成功读取 %d/%d 年份的POS数据\n", n_loaded_pos, length(years)))
if (n_loaded_sos == 0 || n_loaded_pos == 0) {
stop("未找到足够的SOS或POS数据文件")
}
cat("  正在计算SOS多年平均（SOSav）...\n")
sos_stack <- stack(sos_stack_list)
sos_climatology_r <- calc(sos_stack, fun = function(x) { mean(x, na.rm = TRUE) })
sos_climatology_r <- mask_raster(sos_climatology_r, mask_r)
cat("  正在计算POS多年平均（POSav）...\n")
pos_stack <- stack(pos_stack_list)
pos_climatology_r <- calc(pos_stack, fun = function(x) { mean(x, na.rm = TRUE) })
pos_climatology_r <- mask_raster(pos_climatology_r, mask_r)
# 统计气候态信息
sos_clim_vals <- getValues(sos_climatology_r)
sos_clim_vals <- sanitize_values(sos_clim_vals, NAvalue(sos_climatology_r), FALSE)
pos_clim_vals <- getValues(pos_climatology_r)
pos_clim_vals <- sanitize_values(pos_clim_vals, NAvalue(pos_climatology_r), FALSE)
n_valid_sos <- sum(!is.na(sos_clim_vals))
n_valid_pos <- sum(!is.na(pos_clim_vals))
sos_min <- min(sos_clim_vals, na.rm = TRUE)
sos_max <- max(sos_clim_vals, na.rm = TRUE)
sos_mean <- mean(sos_clim_vals, na.rm = TRUE)
pos_min <- min(pos_clim_vals, na.rm = TRUE)
pos_max <- max(pos_clim_vals, na.rm = TRUE)
pos_mean <- mean(pos_clim_vals, na.rm = TRUE)
cat(sprintf("  ✓ 物候气候态计算完成:\n"))
cat(sprintf("    SOSav - 有效像元: %d, 范围: %.1f - %.1f DOY, 平均: %.1f DOY\n",
n_valid_sos, sos_min, sos_max, sos_mean))
cat(sprintf("    POSav - 有效像元: %d, 范围: %.1f - %.1f DOY, 平均: %.1f DOY\n",
n_valid_pos, pos_min, pos_max, pos_mean))
# 保存物候气候态
sos_clim_file <- file.path(DERIVED_DIR, "SOS_climatology.tif")
pos_clim_file <- file.path(DERIVED_DIR, "POS_climatology.tif")
writeRaster(sos_climatology_r, sos_clim_file, overwrite = TRUE, datatype = "FLT4S")
writeRaster(pos_climatology_r, pos_clim_file, overwrite = TRUE, datatype = "FLT4S")
cat(sprintf("  ✓ 物候气候态已保存: %s, %s\n", basename(sos_clim_file), basename(pos_clim_file)))
# 读取Fixed_Window_Length（用于计算Fixed_Trate）
cat("\n=== 读取Fixed_Window_Length ===\n")
fixed_len_file <- file.path(DECOMP_DIR, "Fixed_Window_Length.tif")
if (!file.exists(fixed_len_file)) {
stop(sprintf("Fixed_Window_Length文件不存在: %s", fixed_len_file))
}
fixed_window_length_r <- raster(fixed_len_file)
NAvalue(fixed_window_length_r) <- NODATA_OUT
fixed_window_length_r <- mask_raster(fixed_window_length_r, mask_r)
cat(sprintf("  ✓ Fixed_Window_Length已加载: %s\n", basename(fixed_len_file)))
# 准备缓存
prepare_sem_caches(years, sos_climatology_r, pos_climatology_r,
fixed_window_length_r, mask_r)
# 运行像元时间序列SEM
run_sem_pixel_time_series(years, sos_climatology_r, fixed_window_length_r, mask_r)
} else {
# 全局合并模式
fit <- run_dual_timescale_sem(years, mask_r)
# VIF诊断
sem_data_file <- file.path(DATA_DIR, "sem_dual_timescale_standardized.csv")
if (file.exists(sem_data_file)) {
data <- read.csv(sem_data_file)
vif_vals <- calculate_vif(data)
if (any(vif_vals > 10, na.rm = TRUE)) {
cat("\n⚠️ 警告：检测到VIF > 10，建议移除高VIF变量\n")
}
}
}
cat("\n======================================================================\n")
cat("✓ 双时间尺度SEM分析完成\n")
cat(sprintf("输出目录: %s\n", OUTPUT_DIR))
cat("======================================================================\n")
}
# ==================== 运行 ====================
# 自动运行逻辑
# - 非交互模式（Rscript）：自动运行
# - 交互模式（RStudio）：提示用户手动调用
if (!interactive()) {
main()
} else {
cat("\n======================================================================\n")
cat("⚠️ 交互模式检测\n")
cat("======================================================================\n")
cat("请手动执行以下命令以运行双时间尺度SEM分析:\n\n")
cat("  main()\n\n")
cat("或者使用以下命令在非交互模式运行:\n\n")
cat("  Rscript 05b_SEM_analysis_dual_timescale_SOS.R\n")
cat("======================================================================\n\n")
}
main()
